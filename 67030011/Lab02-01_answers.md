# ใบงานที่ 02.01 เรื่องการประกาศและแสดงผลชนิดข้อมูลพื้นฐาน

---

### ส่วนที่ 2 การทดลองกับ int หรือจำนวนเต็ม

__คำถามที่เกี่ยวข้อง__

*   ผลการทำงานของโค้ดในส่วนต่างๆ ตรงตามหลักคณิตศาสตร์หรือไม่ เพราะอะไร

> #### **มาดูผลลัพธ์และคำตอบกัน**
>
> **ผลการทดลองที่ได้**
> ```
> --- ทดสอบชนิดข้อมูล int (ESP32) ---
> ค่าเริ่มต้นของ myInteger 100
> myInteger = 2147483647 ผลลัพธ์ 2147483647
> myInteger = 2147483647 + 1 ผลลัพธ์ -2147483648
> myInteger = -2147483648 ผลลัพธ์ -2147483648
> myInteger = -2147483648 - 1 ผลลัพธ์ 2147483647
> ```
> **อธิบายผลลัพธ์**
>
> ผลลัพธ์ที่เห็นนี้ช่วยยืนยันหลักการทำงานของ `int` แบบ 32 บิตได้ชัดเจนเลย
>
> *   **Overflow** เกิดขึ้นตอนที่เราบวก `1` เพิ่มเข้าไปในค่าที่สูงสุดแล้ว ทำให้ค่ามัน "ล้น" และวนกลับไปเป็นค่าที่ต่ำที่สุดแทน
> *   **Underflow** ก็จะเกิดในทางตรงกันข้าม คือตอนที่เราลบ `1` ออกจากค่าที่ต่ำที่สุดแล้ว ค่ามันเลยวนกลับไปเป็นค่าที่สูงที่สุด

---

### ส่วนที่ 3 การทดลองกับ float และ double หรือทศนิยม

__คำถามที่เกี่ยวข้อง__

*   เราสังเกตเห็นความแตกต่างของความแม่นยำระหว่าง float กับ double อย่างไรบ้าง
*   ในสถานการณ์ไหนที่เราควรจะเลือกใช้ double แทน float

> #### **ผลลัพธ์และคำตอบ**
>
> **ผลการทดลองที่ได้**
> ```
> --- ทดสอบชนิดข้อมูล float และ double (ESP32) ---
> ค่า myFloat (float) 3.14159274
> ค่า myDouble (double) 3.141592653589793
> ```
> **อธิบายผลลัพธ์**
>
> 1.  **เรื่องความแม่นยำ** จะเห็นว่า `float` ไม่สามารถเก็บค่า `3.14159265` ได้ตรงเป๊ะๆ ค่ามันจะเพี้ยนไปนิดหน่อย แต่ `double` สามารถเก็บได้สมบูรณ์ แสดงว่า `double` แม่นยำกว่ามาก
> 2.  **แล้วจะใช้ double ตอนไหน** เราควรใช้ `double` ในงานที่ต้องการความแม่นยำสูงๆ อย่างการคำนวณทางวิทยาศาสตร์, การเงิน หรือพิกัด GPS

---

### ส่วนที่ 4 การทดลองกับ char หรืออักขระ

__คำถามที่เกี่ยวข้อง__

*   ค่าตัวเลขหรือ ASCII value มีความสัมพันธ์กับอักขระอย่างไร
*   ถ้าอยากรู้ความสัมพันธ์ทั้งหมด จะไปหาข้อมูลได้จากที่ไหน
*   รหัสพวกนี้นักเขียนโปรแกรมกำหนดเองได้ไหม หรือมีมาตรฐานกำกับอยู่

> #### **ผลลัพธ์และคำตอบ**
>
> **ผลการทดลองที่ได้**
> ```
> --- ทดสอบชนิดข้อมูล char ---
> myChar = 'Z' ผลลัพธ์ Z
> myChar ในรูป ASCII 90
> myChar = 122 ผลลัพธ์ z
> ```
> **อธิบายผลลัพธ์**
>
> 1.  **ความสัมพันธ์ของ ASCII กับอักขระ** จริงๆ แล้วคอมพิวเตอร์เก็บตัวอักษรเป็นตัวเลข ซึ่งรหัสตัวเลขนี้เราเรียกว่า ASCII อย่างตัว `Z` ก็คือเลข `90` นั่นเอง
> 2.  **แหล่งข้อมูล** เราหาดูตารางเทียบทั้งหมดได้จาก "ตาราง ASCII" หรือ "ASCII Table" บนอินเทอร์เน็ตเลย
> 3.  **การกำหนดรหัส** นักเขียนโปรแกรมจะกำหนดเองไม่ได้นะ เพราะ ASCII เป็นมาตรฐานสากลที่ใช้กันทั่วโลกเพื่อให้สื่อสารกันได้ถูกต้อง

---

### ส่วนที่ 5 การทดลองกับ bool หรือค่าตรรกะ

__คำถามที่เกี่ยวข้อง__

*   `true` และ `false` ถูกแสดงผลเป็นค่าอะไร

> #### **ผลลัพธ์และคำตอบ**
>
> **ผลการทดลองที่ได้**
> ```
> --- ทดสอบชนิดข้อมูล bool ---
> myBool = true ผลลัพธ์ 1
> myBool = false ผลลัพธ์ 0
> ```
> **อธิบายผลลัพธ์**
>
> *   `true` จะแสดงผลเป็นเลข `1`
> *   `false` จะแสดงผลเป็นเลข `0`

---

### ส่วนที่ 6 การทดลองกับ long และอื่นๆ

__คำถามที่เกี่ยวข้อง__

*   บน ESP32 `long` มีขอบเขตเท่ากับ `int` หรือไม่
*   ถ้าต้องการเก็บค่าจำนวนเต็มบวกที่ใหญ่ที่สุดต้องใช้ชนิดข้อมูลอะไร

> #### **ผลลัพธ์และคำตอบ**
>
> **ผลการทดลองที่ได้**
> ```
> --- ทดสอบชนิดข้อมูล long, long long, unsigned (ESP32) ---
> myLong (4,000,000,000) -294967296
> myLongLong (9,000,000,000,000,000,000) 9000000000000000000
> myUnsignedInt (4,000,000,000) 4000000000
> myUnsignedLong (4,000,000,000) 4000000000
> myUnsignedLongLong (1.8e19) 18000000000000000000
> ```
> **อธิบายผลลัพธ์**
>
> 1.  **`long` กับ `int`** ใช่แล้ว บน ESP32 สองตัวนี้มีขอบเขตเท่ากันเลย ผลลัพธ์ที่ `myLong` ล้นไปก็เป็นตัวยืนยันเรื่องนี้
> 2.  **ค่าที่ใหญ่ที่สุด** ถ้าจะเก็บค่าบวกที่ใหญ่มากๆ ต้องใช้ `unsigned long long` เพราะเป็นแบบ 64 บิตและไม่คิดค่าลบ ทำให้เก็บได้เยอะสุดๆ

---

### ส่วนที่ 7 การทดลองกับ byte

__คำถามที่เกี่ยวข้อง__

*   เมื่อ `myByte` ถูกตั้งค่าเป็น 256 ผลลัพธ์ที่ได้คืออะไร และทำไม

> #### **ผลลัพธ์และคำตอบ**
>
> **ผลการทดลองที่ได้**
> ```
> --- ทดสอบชนิดข้อมูล byte ---
> myByte = 250 ผลลัพธ์ 250
> myByte = 256 ผลลัพธ์ 0
> ```
> **อธิบายผลลัพธ์**
>
> *   ผลลัพธ์ที่ได้คือ `0` เพราะ `byte` เก็บค่าได้แค่ 0 ถึง 255 พอเราใส่ 256 เข้าไป มันก็เลยล้นและวนกลับมาที่จุดเริ่มต้นคือ `0` นั่นเอง
