# ใบงานที่ 02.03 เรื่องการเรียนรู้ชนิดข้อมูลในภาษา C

---

### ส่วนที่ 1 ทดลองกับ int และ sizeof()

__คำถาม__ 

*   int บน ESP32 ใช้กี่ไบต์
*   จากผลลัพธ์ เราสังเกตเห็นอะไรเมื่อค่าเกินขอบเขตของ int

> #### **ผลและคำตอบ**
>
> **ผลการทดลองที่ได้**
> ```
> --- 1. ทดสอบชนิดข้อมูล int (ESP32) ---
> ขนาดของ int 4 bytes
> ค่าเริ่มต้นของ myInteger 100
> myInteger = 2147483647 ผลลัพธ์ 2147483647
> myInteger = 2147483647 + 1 ผลลัพธ์ -2147483648
> myInteger = -2147483648 ผลลัพธ์ -2147483648
> myInteger = -2147483648 - 1 ผลลัพธ์ 2147483647
> ```
> **อธิบายผลลัพธ์**
>
> 1.  จากผลลัพธ์จะเห็นว่า `int` บน ESP32 ใช้พื้นที่ **4 ไบต์**
> 2.  เมื่อค่าเกินขอบเขต มันจะเกิดปรากฏการณ์ที่เรียกว่า **Overflow** และ **Underflow** ซึ่งก็คือการที่ค่ามันวนกลับจากค่าสูงสุดไปหาค่าต่ำสุด หรือจากค่าต่ำสุดไปหาค่าสูงสุดนั่นเอง

---

### ส่วนที่ 2 ทดลองกับ float, double และ sizeof()

__คำถาม__

*   float และ double บน ESP32 ใช้กี่ไบต์
*   เราเห็นความแตกต่างของความแม่นยำระหว่าง float กับ double อย่างไร และควรใช้ double แทน float ตอนไหน

> #### **ผลและคำตอบ**
>
> **ผลการทดลองที่ได้**
> ```
> --- 2. ทดสอบชนิดข้อมูล float และ double (ESP32) ---
> ขนาดของ float 4 bytes
> ขนาดของ double 8 bytes
> ค่า myFloat (float) 3.14159274
> ค่า myDouble (double) 3.141592653589793
> ```
> **อธิบายผลลัพธ์**
>
> *   `float` ใช้ **4 ไบต์** ส่วน `double` ใช้ **8 ไบต์**
> *   ความแม่นยำของ `double` นั้นสูงกว่า `float` มาก เราควรเลือกใช้ `double` ในงานที่ต้องการความละเอียดสูงๆ อย่างการคำนวณทางวิทยาศาสตร์

---

### ส่วนที่ 3 ทดลองกับ char และ sizeof()

__คำถาม__

*   char ใช้กี่ไบต์ แล้วค่าตัวเลข ASCII มีความสัมพันธ์กับอักขระอย่างไร

> #### **ผลและคำตอบ**
>
> **ผลการทดลองที่ได้**
> ```
> --- 3. ทดสอบชนิดข้อมูล char ---
> ขนาดของ char 1 bytes
> myChar = 'Z' ผลลัพธ์ Z
> myChar ในรูป ASCII 90
> myChar = 122 ผลลัพธ์ z
> ```
> **อธิบายผลลัพธ์**
>
> *   `char` ใช้พื้นที่ **1 ไบต์**
> *   ความสัมพันธ์ของมันก็คือ อักษรทุกตัวมีรหัสตัวเลข หรือ **ASCII** เป็นของตัวเอง อย่าง `Z` ก็คือเลข `90`

---

### ส่วนที่ 4 ทดลองกับ bool และ sizeof()

__คำถาม__

*   bool ใช้กี่ไบต์ แล้ว true กับ false แสดงผลเป็นค่าอะไร

> #### **ผลและคำตอบ**
>
> **ผลการทดลองที่ได้**
> ```
> --- 4. ทดสอบชนิดข้อมูล bool ---
> ขนาดของ bool 1 bytes
> myBool = true ผลลัพธ์ 1
> myBool = false ผลลัพธ์ 0
> ```
> **อธิบายผลลัพธ์**
>
> *   `bool` ใช้ **1 ไบต์**
> *   `true` จะแสดงเป็นเลข `1` ส่วน `false` จะแสดงเป็น `0`

---

### ส่วนที่ 5 ทดลองกับ long, long long, unsigned และ sizeof()

__คำถาม__

*   ข้อมูลแต่ละชนิดในกลุ่มนี้ใช้กี่ไบต์
*   `long` มีขอบเขตเท่ากับ `int` หรือไม่ แล้วถ้าอยากเก็บค่าบวกที่ใหญ่ที่สุดต้องใช้อะไร

> #### **ผลและคำตอบ**
>
> **ผลการทดลองที่ได้**
> ```
> --- 5. ทดสอบชนิดข้อมูล long, long long, unsigned (ESP32) ---
> ขนาดของ long 4 bytes
> ขนาดของ long long 8 bytes
> ขนาดของ unsigned int 4 bytes
> ขนาดของ unsigned long 4 bytes
> ขนาดของ unsigned long long 8 bytes
> myLong (4,000,000,000) -294967296
> ...
> ```
> **อธิบายผลลัพธ์**
>
> *   ขนาดของแต่ละตัวคือ `long` (4), `long long` (8), `unsigned int` (4), `unsigned long` (4), และ `unsigned long long` (8)
> *   บน ESP32 `long` มีขอบเขต**เท่ากับ `int`**
> *   ถ้าอยากได้ค่าบวกที่ใหญ่ที่สุด ต้องใช้ **`unsigned long long`**

---

### ส่วนที่ 6 ทดลองกับ byte และ sizeof()

__คำถาม__

*   byte ใช้กี่ไบต์ แล้วถ้ากำหนดค่าเป็น 256 จะเกิดอะไรขึ้น

> #### **ผลและคำตอบ**
>
> **ผลการทดลองที่ได้**
> ```
> --- 6. ทดสอบชนิดข้อมูล byte ---
> ขนาดของ byte 1 bytes
> myByte = 250 ผลลัพธ์ 250
> myByte = 256 ผลลัพธ์ 0
> ```
> **อธิบายผลลัพธ์**
>
> *   `byte` ใช้ **1 ไบต์**
> *   เมื่อใส่ค่า `256` ผลลัพธ์จะกลายเป็น `0` เพราะมันเกิด Overflow วนกลับมาที่จุดเริ่มต้นนั่นเอง

---

### ส่วนที่ 7 และ 8 เรื่องการแปลงชนิดข้อมูล

__คำถาม__

*   ทำไมการหารเลขบางครั้งได้ทศนิยม บางครั้งไม่ได้
*   เราจะใช้ Type Casting ตอนไหนบ้าง

> #### **ผลและคำตอบ**
>
> **ผลการทดลองที่ได้**
> ```
> --- 7. ทดสอบการคำนวณระหว่างชนิดข้อมูล ---
> 10 / 3.0 (ผลลัพธ์ float) 3.33
> 10 / 3.0 (ผลลัพธ์ double) 3.3333333333
> 10 / (int)3.0 (ผลลัพธ์ int) 3
> --- 8. ทดสอบการแปลงชนิดข้อมูล (Type Casting) ---
> อุณหภูมิ Celsius (float) 25.79
> อุณหภูมิ Celsius (แปลงเป็น int) 25
> อักขระ 'P' มีค่า ASCII 80
> ค่าเฉลี่ย (7/20) 0.35
> ```
> **อธิบายผลลัพธ์**
>
> *   ที่ผลการหารต่างกันเพราะหลัก **Type Promotion** ถ้าตัวหารเป็น `float` ผลลัพธ์ก็จะเป็น `float` แต่ถ้าหาร `int` กับ `int` ผลลัพธ์จะถูกปัดเศษทิ้ง
> *   เราจะใช้ **Type Casting** หรือการบังคับแปลงข้อมูลก็ต่อเมื่ออยากได้ผลลัพธ์ที่เฉพาะเจาะจง เช่น อยากให้การหารเลขจำนวนเต็มได้ทศนิยม หรืออยากตัดทศนิยมทิ้ง