คำถามข้อ 2

คำถาม

2.1 สังเกตผลจากการรันโคิดในส่วน 2.1 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด

2.2 สังเกตผลจากการรันโคิดในส่วน 2.2 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด

2.3 สังเกตผลจากการรันโคิดในส่วน 2.3 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด

2.4 สังเกตผลจากการรันโคิดในส่วน 2.4 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด

2.5 สังเกตผลจากการรันโคิดในส่วน 2.5 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด

คำตอบ

2.1 ตรงตามหลักการทางคณิตศาสตร์ เพราะ 100 อยู่ในช่วงที่ int รองรับ (−2,147,483,648 ถึง 2,147,483,647 บน ESP32)

2.2 ตรงตามหลักการ เพราะ 2,147,483,647 คือค่าสูงสุดของ int (32-bit signed) ดังนั้นแสดงค่าได้ถูกต้อง

2.3 ไม่ตรงหลักการทางคณิตศาสตร์ เพราะเกิด overflow: ตัวแปร int มีค่าสูงสุดอยู่ที่ 2,147,483,647 เมื่อลองเพิ่มอีก 1 ระบบจะวนกลับไปที่ค่าต่ำสุด (−2,147,483,648)

2.4 ตรงตามหลักการ เพราะเป็นค่าต่ำสุดของ int ที่สามารถเก็บได้

2.5 ไม่ตรงหลักการทางคณิตศาสตร์ เพราะเกิด underflow: ค่าจะวนกลับไปยังค่าสูงสุดของ int อีกครั้ง


คำถามข้อ 3

3.1 ความแตกต่าง:

float แสดงค่าได้ประมาณ 6-7 ตำแหน่งทศนิยมเท่านั้น

double แสดงได้ถึง 15 ตำแหน่ง (แม่นยำกว่า)

สังเกตว่า float ถูกปัดค่าหลังตำแหน่งที่ 6-7 ขึ้นไป เช่น float อาจแสดง 3.14159274 แทน 3.14159265


3.2 เมื่อควรใช้ double:

เมื่อต้องการความแม่นยำสูง เช่น การคำนวณฟิสิกส์, พิกัด GPS, คณิตศาสตร์ขั้นสูง

แต่ถ้าเป็นงานทั่วไป หรือทรัพยากรจำกัด เช่น งาน IoT ที่ใช้พลังงานต่ำ อาจใช้ float


คำถามข้อ 4

4.1 ความสัมพันธ์:

ตัวแปร char เก็บเป็นตัวเลข ASCII เช่น 'Z' มีค่าเท่ากับ 90

ค่าตัวเลขจะถูกแปลงเป็นอักขระตามตาราง ASCII


4.2 แหล่งข้อมูล:

ตาราง ASCII: สามารถค้นหาได้ทั่วไป เช่นจาก https://www.asciitable.com


4.3 นักเขียนโปรแกรมไม่สามารถกำหนด ASCII เองได้ เป็นมาตรฐานที่กำหนดโดย ANSI (American National Standards Institute)



คำถามข้อ 5

5.1 บน Serial Monitor:

true แสดงเป็น 1

false แสดงเป็น 0
เพราะ bool ภายในถูกเก็บเป็นเลข 1 บิต คือ 0 หรือ 1


คำถามข้อ 6

6.1 บน ESP32:

long มีขนาด 32-bit เช่นเดียวกับ int ดังนั้น มีขอบเขตเท่ากัน


6.2 ถ้าต้องการเก็บค่าจำนวนเต็มบวกที่ใหญ่ที่สุด:

ใช้ unsigned long long (64-bit) เก็บค่าได้ถึง ~18 quintillion (1.8 × 10^19)


คำถามข้อ 7
ผลลัพธ์ของ myByte = 256;:

ไม่ได้แสดงเป็น 256 เพราะ byte เก็บได้สูงสุดเพียง 255 (8-bit unsigned)

256 % 256 = 0 → จึงแสดงผลเป็น 0

เกิด wrap-around (overflow)
