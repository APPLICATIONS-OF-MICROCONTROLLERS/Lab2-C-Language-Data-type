1.1 int บน ESP32 ใช้กี่ไบต์?
ตอบ บน ESP32 ตัวแปรชนิด int ใช้ 4 ไบต์ (bytes)

1.2 จากผลลัพธ์ นักศึกษาสังเกตเห็นอะไรเมื่อค่าเกินขอบเขตของ int บน ESP32?
ตอบ เมื่อค่าของ int เกินขอบเขตที่รองรับ (เช่น มากกว่า 2,147,483,647 หรือ น้อยกว่า -2,147,483,648) จะเกิด Overflow หรือ Underflow ซึ่งทำให้ค่าที่ได้ "วนกลับ" ไปอีกฝั่งหนึ่ง
เมื่อใส่ค่า 2147483647 + 1  ได้ -2147483648 (เกิด Overflow)เมื่อใส่ค่า -2147483648 - 1 ได้ 2147483647 (เกิด Underflow)

float และ double บน ESP32 ใช้กี่ไบต์ตามลำดับ?
ตอบ float ใช้ 4 ไบต์ double ใช้ 8 ไบต์

นักศึกษาสังเกตเห็นความแตกต่างของความแม่นยำระหว่าง float และ double อย่างไร? สถานการณ์ใดที่คุณควรเลือกใช้ double แทน float?
ตอบ  - ความแตกต่างของความแม่นยำระหว่าง float และ double:
จากผลการรันจะเห็นว่า float แสดงค่า Pi ได้ประมาณ 3.14159274 แม่นยำประมาณ 6–7 ตำแหน่ง 
double แสดงค่า Pi ได้ประมาณ 3.141592653589793 แม่นยำประมาณ 15 ตำแหน่ง
     - สถานการณ์ที่ควรใช้ double แทน float เมื่อทำการคำนวณที่ต้องการ ความแม่นยำสูง เช่นงานวิทยาศาสตร์
การคำนวณทางคณิตศาสตร์ขั้นสูงพิกัด GPS ความละเอียดสูงหรือเมื่อต้องเก็บค่าทศนิยมหลายตำแหน่งเพื่อหลีกเลี่ยงความคลาดเคลื่อน

char ใช้กี่ไบต์? ค่าตัวเลข (ASCII value) มีความสัมพันธ์กับอักขระอย่างไร?
ตอบ ชนิดข้อมูล `char` ใช้ 1 ไบต์ และเก็บค่าตัวเลขที่ตรงกับรหัส ASCII ของอักขระ เช่น ตัวอักษร `'Z'` มีค่า ASCII เท่ากับ 90 และเมื่อกำหนดค่า 122 ให้กับตัวแปร `char` จะแสดงเป็นตัวอักษร `'z'` ซึ่งแสดงให้เห็นว่าค่าตัวเลข ASCII มีความสัมพันธ์โดยตรงกับอักขระที่แสดงผล.

bool ใช้กี่ไบต์? true และ false ถูกแสดงผลเป็นค่าใดบน Serial Monitor?
ตอบ ชนิดข้อมูล `bool` ใช้ **1 ไบต์** และค่าของ `true` จะถูกแสดงเป็น **1** ส่วน `false` จะแสดงเป็น **0** บน Serial Monitor.

ชนิดข้อมูลจำนวนเต็มแต่ละชนิด (long, long long, unsigned int, unsigned long, unsigned long long) ใช้กี่ไบต์บน ESP32?
ตอบ long ใช้ 4 ไบต์ long long ใช้ 8 ไบต์ unsigned int ใช้ 4 ไบต์ unsigned long ใช้ 4 ไบต์ unsigned long long ใช้ 8 ไบต์

บน ESP32, long มีขอบเขตเท่ากับ int หรือไม่? ชนิดข้อมูลใดที่คุณจะใช้หากต้องการเก็บค่าจำนวนเต็มบวกที่ใหญ่ที่สุด?
ตอบ ใช่, long บน ESP32 มีขนาด 4 ไบต์ เท่ากับ int และมีขอบเขตค่าที่รองรับเท่ากัน
ดังนั้น ถ้าค่าที่ต้องการเก็บเกินขอบเขตของ int ก็จะเกิด overflow เช่นในกรณี myLong = 4000000000 (ซึ่งเกินขอบเขตสูงสุดของ signed 32-bit)
ถ้าต้องการเก็บค่าจำนวนเต็มที่มีค่ามากเกินกว่า 2,147,483,647 (32-bit signed) ควรใช้ long long หรือ unsigned long long (64-bit)
ถ้าต้องการเก็บค่าจำนวนเต็มบวกที่ไม่ต้องการค่าลบ และค่ามีขนาดใหญ่ ควรใช้ชนิด unsigned เช่น unsigned long หรือ unsigned long long
สำหรับค่าปกติที่อยู่ในขอบเขต 32-bit signed ใช้ int หรือ long ก็ได้

byte ใช้กี่ไบต์? เมื่อ myByte ถูกกำหนดให้เป็น 256 ผลลัพธ์ที่ได้คืออะไร และเพราะเหตุใด?
ตอบ ชนิดข้อมูล `byte` ใช้ **1 ไบต์** เมื่อกำหนดค่า `myByte = 256` ซึ่งเกินขอบเขตของ `byte` ที่รับได้คือ 0–255 ผลลัพธ์จึงเป็น **0** เพราะเกิดการล้นค่า (overflow) ทำให้ค่าที่เกิน 256 จะวนกลับเริ่มนับจาก 0 ใหม่.

ทำไม 10 / 3.0 (เมื่อตัวหารเป็น float หรือ double) ถึงได้ผลลัพธ์เป็นทศนิยม แต่เมื่อตัวหารถูกแปลงเป็น int แล้วผลลัพธ์เป็นจำนวนเต็ม?
ตอบ เมื่อมีการหารระหว่างจำนวนเต็ม (`int`) กับจำนวนทศนิยม (`float` หรือ `double`) ตัวจำนวนเต็มจะถูกแปลงเป็นทศนิยมโดยอัตโนมัติก่อนทำการคำนวณ
ทำให้ผลลัพธ์ออกมาเป็นทศนิยม เช่น `10 / 3.0` จะกลายเป็น `10.0 / 3.0` และได้ผลลัพธ์เป็นทศนิยม แต่ถ้าตัวหารถูกแปลงเป็น `int` ก่อน เช่น `(int)3.0` จะทำให้การหารเป็นแบบจำนวนเต็ม (`int / int`) ซึ่งผลลัพธ์จะตัดส่วนทศนิยมออก ทำให้ได้ค่าจำนวนเต็มเท่านั้น เช่น `10 / 3`ให้ผลลัพธ์เป็น `3` โดยตัดเศษทิ้ง.

นักศึกษาจะใช้การทำ Type Casting ในสถานการณ์ใดบ้างในการเขียนโปรแกรม?
ตอบ -เมื่อต้องการแปลงค่าทศนิยมให้เป็นจำนวนเต็ม เช่น แปลง float เป็น int เพื่อตัดทศนิยมออก เช่น (int)temperatureCelsius
    -เมื่อต้องการหารแล้วให้ได้ผลลัพธ์เป็นทศนิยม เช่น แปลง int เป็น float ก่อนหาร เพื่อป้องกันการตัดเศษ เช่น (float)count / total
    -เมื่อต้องการดูรหัส ASCII ของอักขระ เช่น แปลง char เป็น int เช่น (int)'P' จะได้ 80
    -เมื่อตัวแปรมีชนิดข้อมูลไม่ตรงกับที่ฟังก์ชันต้องการ เช่น ฟังก์ชันต้องการ float แต่เรามี int
    -เมื่อต้องการควบคุมผลลัพธ์ของการคำนวณให้ตรงกับชนิดข้อมูลที่ต้องการ เช่น ป้องกันการคำนวณผิดพลาดจากการตัดค่าทศนิยมโดยไม่ได้ตั้งใจ




 
