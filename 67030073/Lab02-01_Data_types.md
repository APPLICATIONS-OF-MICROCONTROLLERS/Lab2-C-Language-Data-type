คำตอบใบงานที่ 02.01 การประกาศและแสดงผลชนิดข้อมูลพื้นฐาน
ส่วนที่ 2: ทดลองกับ int (จำนวนเต็ม)
2.1 สังเกตผลจากการรันโค้ดในส่วน 2.1 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
ตอบ: ตรงตามหลักการทางคณิตศาสตร์ เพราะเป็นการกำหนดค่า int myInteger = 100; ซึ่งเท่ากับการระบุค่าคงที่ให้ตัวแปรในเชิงคณิตศาสตร์ เช่นเดียวกับการเขียน x = 100 ในสมการทั่วไป จากนั้นนำค่าไปแสดงผ่าน Serial.println() โดยไม่มีการดำเนินการเพิ่มเติมหรือผิดพลาดในการคำนวณ
2.2 สังเกตผลจากการรันโค้ดในส่วน 2.2 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
ตอบ: ตรงตามหลักการทางคณิตศาสตร์

ค่านี้คือค่ามากสุดของ int แบบ signed (32-bit) ซึ่งก็คือ 2³¹ - 1
การกำหนดค่านี้ไม่เกิดความผิดปกติ → ผลลัพธ์จะแสดง 2147483647 ซึ่งถูกต้อง

2.3 สังเกตผลจากการรันโค้ดในส่วน 2.3 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
ตอบ: ไม่ตรงตามหลักการคณิตศาสตร์ในทางทฤษฎี แต่ตรงตามหลักการของระบบคอมพิวเตอร์

ในคณิตศาสตร์จริง ๆ ผลลัพธ์ควรเป็น 2147483648
แต่ ESP32 ใช้ตัวแปรแบบ int ซึ่งมีขอบเขตแค่ถึง 2147483647 → เกินขอบเขต = overflow
ดังนั้นค่าจะ "วนกลับ" เป็น -2147483648 ซึ่งเป็นค่าต่ำสุดของ signed int

2.4 สังเกตผลจากการรันโค้ดในส่วน 2.4 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
ตอบ: ตรงตามหลักการทางคณิตศาสตร์

ค่านี้คือค่าต่ำสุดของ signed 32-bit int → -2³¹
ไม่มีการผิดพลาดในการคำนวณ → ผลลัพธ์ตรงกับที่กำหนดไว้

2.5 สังเกตผลจากการรันโค้ดในส่วน 2.5 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
ตอบ: ไม่ตรงตามหลักการทางคณิตศาสตร์โดยตรง แต่เป็นผลตามหลักการทำงานของหน่วยประมวลผล

ในทางคณิตศาสตร์ควรเป็น -2147483649
แต่ ESP32 ไม่รองรับค่าต่ำกว่าขอบเขตนี้ → เกิด underflow
ผลลัพธ์จะ "วนกลับ" เป็น 2147483647 ซึ่งเป็นค่าบวกมากสุด

ส่วนที่ 3: ทดลองกับ float และ double (ทศนิยม)
3.1 คุณสังเกตเห็นความแตกต่างของความแม่นยำระหว่าง float และ double อย่างไร?
ตอบ: double มีความแม่นยำสูงกว่า float เพราะรองรับตำแหน่งทศนิยมได้มากกว่า ทำให้ค่าที่แสดงมีความใกล้เคียงกับค่าที่ตั้งไว้มากกว่า float ซึ่งอาจเกิดการปัดเศษหรือคลาดเคลื่อนได้
3.2 สถานการณ์ใดที่คุณควรเลือกใช้ double แทน float?
ตอบ: ควรใช้ double เมื่อทำงานที่ต้องการความละเอียดของข้อมูลสูง เช่น:

การคำนวณทางวิทยาศาสตร์
การจำลองที่ต้องการค่าทศนิยมมาก
การวิเคราะห์ข้อมูลที่มีความละเอียดมากกว่าปกติ

ส่วนที่ 4: ทดลองกับ char (อักขระ)
4.1 ค่าตัวเลข (ASCII value) มีความสัมพันธ์กับอักขระอย่างไร?
ตอบ: ค่าตัวเลขแบบ ASCII คือการแทนสัญลักษณ์หรืออักขระด้วยตัวเลข เช่น 'Z' จะมีค่าเป็น 90 และ 'z' จะมีค่าเป็น 122 การเปลี่ยนค่าตัวเลขจึงส่งผลต่ออักขระทันทีเมื่อแสดงผล เช่น การใช้ (int)myChar เพื่อดูค่า ASCII
4.2 ถ้าอยากทราบความสัมพันธ์ระหว่างตัวเลขกับอักขระทั้งหมด สามารถหาได้จากเอกสารใด หรือแหล่งอ้างอิงใด
ตอบ: สามารถอ้างอิงจากตาราง ASCII (ASCII Table) ซึ่งมีทั้งอักขระภาษาอังกฤษ เครื่องหมายพิเศษ และตัวเลข พร้อมค่าตัวเลขที่เกี่ยวข้อง
แหล่งค้นหา:
เอกสารมาตรฐานของ ANSI (American National Standards Institute)
เว็บไซต์ programming เช่น ascii-code.com, Arduino Reference, หรือคู่มือภาษา C/C++

4.3 จากข้อ 4.2 นักเขียนโปรแกรมสามารถกำหนดขึ้นเองได้ หรือมีเอกสารใดกำกับอยู่
ตอบ: ไม่สามารถกำหนดเองได้ เพราะ ASCII เป็นมาตรฐานสากลที่ใช้ในการสื่อสารข้อมูลผ่านคอมพิวเตอร์และอุปกรณ์อิเล็กทรอนิกส์ จำเป็นต้องยึดตามเอกสารที่ ANSI กำหนด เพื่อให้เกิดความเข้ากันได้ในทุกระบบ
ส่วนที่ 5: ทดลองกับ bool (ตรรกะ)
5.1 true และ false ถูกแสดงผลเป็นค่าใดบน Serial Monitor?
ตอบ: true จะแสดงเป็นค่า 1 และ false จะแสดงเป็นค่า 0 บน Serial Monitor เพราะ Arduino แปลงค่าตรรกะเป็นตัวเลขตามมาตรฐานคอมพิวเตอร์
ส่วนที่ 6: ทดลองกับ long, long long, unsigned int, unsigned long, unsigned long long
6.1 บน ESP32, long มีขอบเขตเท่ากับ int หรือไม่?
ตอบ: บน ESP32 ชนิดข้อมูล int และ long มีขอบเขตเท่ากัน เพราะทั้งสองเป็นแบบ signed 32-bit ทำให้สามารถเก็บค่าตั้งแต่ -2,147,483,648 ถึง 2,147,483,647 ได้เท่ากัน ดังนั้นการใช้ long บน ESP32 จะไม่ได้เพิ่มความสามารถในการเก็บค่ามากกว่าการใช้ int แต่อย่างใด ซึ่งต่างจากบางแพลตฟอร์มที่ long อาจเป็น 64-bit ได้
6.2 ชนิดข้อมูลใดที่ต้องใช้หากต้องการเก็บค่าจำนวนเต็มบวกที่ใหญ่ที่สุด?
ตอบ: หากต้องการเก็บจำนวนเต็มบวกขนาดใหญ่เกินกว่าขอบเขตของ 32-bit เช่น ค่าที่มากกว่า 4,294,967,295 ควรใช้ชนิดข้อมูล unsigned long long ซึ่งเป็นแบบ unsigned 64-bit โดยสามารถเก็บค่าได้ตั้งแต่ 0 ถึง 18,446,744,073,709,551,615 ทำให้เหมาะสำหรับงานที่ต้องการความละเอียดสูงหรือเก็บตัวเลขขนาดใหญ่ เช่น:

การจัดการหมายเลขไอดีจำนวนมาก
การคำนวณเวลานาน ๆ
เก็บข้อมูลจากอุปกรณ์ IoT แบบละเอียด

ส่วนที่ 7: ทดลองกับ byte (ข้อมูล 8 บิต)
7.1 เมื่อ myByte ถูกกำหนดให้เป็น 256 ผลลัพธ์ที่ได้คืออะไร และเพราะเหตุใด?
ตอบ: เมื่อกำหนดค่า myByte = 256 บน ESP32 จะเกิด overflow เพราะชนิดข้อมูล byte มีขนาดเพียง 8 บิต ซึ่งสามารถเก็บค่าได้ในช่วง 0 ถึง 255 เท่านั้น การกำหนดค่า 256 จึงเกินขอบเขตสูงสุดที่ชนิดข้อมูลนี้รองรับ ระบบจะจัดการโดยวนค่ากลับตามหลัก modulo 256 ทำให้ค่าที่ถูกจัดเก็บจริงกลายเป็น 0 ซึ่งเป็นผลลัพธ์ที่แสดงออกมาทาง Serial Monitor
พฤติกรรมเช่นนี้เป็นลักษณะทั่วไปของการใช้ชนิดข้อมูลในระบบคอมพิวเตอร์ที่มีขนาดจำกัด โดยเฉพาะเมื่อใช้กับไมโครคอนโทรลเลอร์หรืออุปกรณ์ฝังตัวอย่าง ESP32 หากต้องการเก็บค่าที่ใหญ่กว่า 255 อย่างปลอดภัย ควรใช้ชนิดข้อมูลที่มีขอบเขตกว้างกว่า เช่น int, unsigned int, หรือ unsigned long
