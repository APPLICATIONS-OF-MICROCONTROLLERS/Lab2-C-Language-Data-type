__คำถาม__

2.1  สังเกตผลจากการรันโคิดในส่วน 2.1 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
ตรงตามหลักการทางคณิตศาสตร์
เพราะกำหนดค่า myInteger = 100; และแสดงผลออกมาเป็น 100 ตามค่าที่เก็บในตัวแปรโดยไม่มีการเปลี่ยนแปลง

2.2  สังเกตผลจากการรันโคิดในส่วน 2.2 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
ตรงตามหลักการทางคณิตศาสตร์
เพราะ 2147483647 คือค่า สูงสุด ที่สามารถเก็บได้ในชนิดข้อมูล int (32-bit signed) ดังนั้นเมื่อกำหนดค่าเป็น 2147483647 จึงแสดงค่าตามที่กำหนดถูกต้อง

2.3  สังเกตผลจากการรันโคิดในส่วน 2.3 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
ไม่ตรงตามหลักการทางคณิตศาสตร์ปกติ (เพราะทางคณิตศาสตร์ 2147483647 + 1 = 2147483648)
แต่ตรงตามหลักการของคอมพิวเตอร์ (Overflow)

2.4  สังเกตผลจากการรันโคิดในส่วน 2.4 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
ตรงตามหลักการทางคณิตศาสตร์
เพราะกำหนดค่า myInteger = -2147483648; ซึ่งเป็นค่าต่ำสุดของ int (32-bit signed) แสดงผลออกมาตรงกับค่าที่กำหนด

2.5  สังเกตผลจากการรันโคิดในส่วน 2.5 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
ม่ตรงตามหลักการทางคณิตศาสตร์ปกติ (เพราะทางคณิตศาสตร์ -2147483648 - 1 = -2147483649 ซึ่งเกินขอบเขต int)
แต่ตรงตามหลักการของคอมพิวเตอร์ (Underflow)



__คำถาม__ 

3.1 คุณสังเกตเห็นความแตกต่างของความแม่นยำระหว่าง float และ double อย่างไร? 
float

แสดงค่า π = 3.14159274 (ความละเอียด ~7-8 ตำแหน่ง)

double

แสดงค่า π = 3.141592653589793 (ความละเอียด ~15-16 ตำแหน่ง)

ความแตกต่าง:
float (32-bit) ความแม่นยำประมาณ 7 หลักสำคัญ (significant digits)
double (64-bit) ความแม่นยำประมาณ 15-16 หลักสำคัญ

3.2 สถานการณ์ใดที่คุณควรเลือกใช้ double แทน float?
เลือกใช้ double เมื่อ 

ต้องการความแม่นยำสูง
เช่น คำนวณทางคณิตศาสตร์ วิศวกรรม ฟิสิกส์ หรือการเงินที่ต้องการทศนิยมมาก

ประมวลผลตัวเลขช่วงกว้างมาก
เช่น Scientific computing, Simulation, Machine Learning บางโมเดล

เก็บค่าทศนิยมที่ละเอียด
เช่น ค่าคงที่ฟิสิกส์ (Speed of light, Planck’s constant) หรือการคำนวณวงโคจรดาวเทียม



__คำถาม__
4.1 ค่าตัวเลข (ASCII value) มีความสัมพันธ์กับอักขระอย่างไร?

ค่าตัวเลข (ASCII value) คือรหัสประจำตัวของอักขระแต่ละตัว เช่น 'Z' มีค่า 90 และ 122 คือ 'z'

4.2 ถ้าอยากทราบความสัมพันธ์ระหว่างตัวเลขกับอักขระทั้งหมด สามารถหาได้จากเอกสารใด หรือแหล่งอ้างอิงใด?

ดูได้จาก ตาราง ASCII (ASCII Table) ซึ่งเป็นมาตรฐานที่กำหนดไว้

4.3 จากข้อ 4.2 นักเขียนโปรแกรมสามารถกำหนดขึ้นเองได้ หรือมีเอกสารใดกำกับอยู่?

ไม่สามารถกำหนดเองได้ เพราะค่าเหล่านี้ถูกกำหนดเป็นมาตรฐานสากลใน เอกสารมาตรฐาน ASCII แล้ว

__คำถาม__
5.1 true และ false ถูกแสดงผลเป็นค่าใดบน Serial Monitor?

true ถูกแสดงผลเป็น 1

false ถูกแสดงผลเป็น 0



__คำถาม__
6.1 บน ESP32, long มีขอบเขตเท่ากับ int หรือไม่?

บน ESP32, long มีขอบเขตเท่ากับ int ครับ ทั้งคู่เป็นตัวแปรแบบ 32-bit (บิต)

จากโค้ดตัวอย่าง เราลองกำหนดค่า 4,000,000,000 (สี่พันล้าน) ให้กับ long myLong ซึ่งค่านี้เกินขอบเขตสูงสุดของ 32-bit integer แบบมีเครื่องหมาย (ประมาณ 2.1 พันล้าน)

ผลลัพธ์ที่ Serial Monitor แสดงออกมาเป็นค่าติดลบ (-294967296) ซึ่งบ่งชี้ว่าเกิดภาวะ "Overflow" คือค่าที่เก็บเกินความสามารถของตัวแปร ทำให้ข้อมูลผิดพลาด

แต่เมื่อใช้ long long myLongLong (ซึ่งเป็น 64-bit) กลับสามารถเก็บค่า 9,000,000,000,000,000,000 ได้อย่างถูกต้อง แสดงว่า long long คือชนิดข้อมูลที่ใหญ่กว่าและต่างจาก long บน ESP32

6.2 ชนิดข้อมูลใดที่ต้องใช้หากต้องการเก็บค่าจำนวนเต็มบวกที่ใหญ่ที่สุด?

หากต้องการเก็บค่าจำนวนเต็ม บวก ที่ใหญ่ที่สุด คุณควรใช้ชนิดข้อมูล unsigned long long

unsigned หมายถึง "ไม่มีเครื่องหมาย" (คือไม่มีค่าลบ) ทำให้สามารถใช้บิตทั้งหมดเพื่อเก็บค่าบวกได้เต็มที่

long long หมายถึงเป็น 64-bit (บิต) ซึ่งมีขนาดใหญ่เป็นสองเท่าของ 32-bit (int หรือ long ปกติ)

จากตัวอย่างในโค้ด unsigned long long myUnsignedLongLong สามารถเก็บค่า 18,000,000,000,000,000,000 (สิบแปดล้านล้านล้านล้าน) ได้อย่างถูกต้อง ซึ่งเป็นค่าบวกที่ใหญ่ที่สุดในตัวอย่างนี้ครับ



__คำถาม__
7 เมื่อ myByte ถูกกำหนดให้เป็น 256 ผลลัพธ์ที่ได้คืออะไร และเพราะเหตุใด?

ผลลัพธ์ที่ได้: เมื่อ myByte ถูกกำหนดให้เป็น 256 (ในบรรทัดที่ 9) และพิมพ์ค่าออกมา (บรรทัดที่ 11) ผลลัพธ์ที่แสดงบน Serial Monitor คือ myByte = 256 ผลลัพธ์: 0

เพราะเหตุใด:

ชนิดข้อมูล byte เป็นชนิดข้อมูลแบบ "unsigned 8-bit integer" ซึ่งหมายความว่าจะสามารถเก็บค่าจำนวนเต็มบวกได้ตั้งแต่ 0 ถึง 255 เท่านั้น

เมื่อเราพยายามกำหนดค่า 256 ให้กับตัวแปร myByte ซึ่งเกินขีดจำกัดสูงสุดที่ 255 ตัวแปรจะเกิดภาวะ "Overflow" (ค่าล้น)

ในกรณีของ unsigned integer เมื่อเกิด overflow ค่าจะ "วนกลับ" (wrap around) ไปเริ่มต้นที่ 0 ใหม่ กล่าวคือ 255 + 1 จะกลายเป็น 0 (เหมือนนาฬิกาที่หมุนครบ 24 ชั่วโมงแล้วกลับไปที่ 0)

ดังนั้น ค่า 256 ที่พยายามเก็บ จึงถูกตัดทอน (truncated) หรือวนกลับกลายเป็น 0 นั่นเองครับ
