### 2. ทดลองกับ int (จำนวนเต็ม):
   2.1 ตรงตามหลักการทางคณิตศาสตร์ เพราะ int myInteger = 100; เป็นการกำหนดค่าปกติภายในช่วงที่ int รองรับ
   
   2.2 ตรงตามหลักการ เพราะ 2147483647 คือค่าสูงสุดของ int 32-bit
   
   2.3 ไม่ตรงตามหลักการทางคณิตศาสตร์ เพราะเกิด overflow → ค่าเกินขอบเขตทำให้วนกลับเป็นค่าลบ
   
   2.4 ตรงตามหลักการ -2147483648 เป็นค่าต่ำสุดของ int 32-bit
   
   2.5 ไม่ตรงตามหลักการ เพราะเกิด underflow → ค่าต่ำกว่าขอบเขตจะวนกลับเป็นค่าบวก

### 3. ทดลองกับ float และ double (ทศนิยม):
   3.1  float จะแสดงทศนิยมได้ แม่นยำน้อยกว่า เช่น ปัดทศนิยมหลังตำแหน่งที่ 6–7 double จะแสดงได้แม่นยำถึง ~15 ตำแหน่ง
   
   3.2 ใช้ double เมื่อจำเป็นต้องใช้ ความแม่นยำสูงมาก เช่นในการคำนวณวิทยาศาสตร์, พิกัด GPS, การประมวลผลภาพ/เสียง

### 4. ทดลองกับ char (อักขระ)
   4.1 ตัวอักษรแต่ละตัวมี รหัส ASCII เช่น 'Z' = 90, 'z' = 122 การเก็บแบบนี้ทำให้คอมพิวเตอร์เข้าใจตัวอักษรเป็นตัวเลข
   
   4.2 สามารถดูได้จาก ตาราง ASCII ซึ่งมีในเว็บไซต์ทั่วไป
   
   4.3 ไม่สามารถกำหนดเองได้ เพราะ กำหนดโดยมาตรฐาน ASCII ซึ่งเป็นสากล

### 5. ทดลองกับ bool (ตรรกะ)
   5.1 - true แสดงเป็น 1
       - false แสดงเป็น 0
เป็นการแสดงผลแบบเลขฐานสองที่ใช้ในตรรกศาสตร์

### 6. ทดลองกับ long, long long, unsigned int, unsigned long, unsigned long long (จำนวนเต็มขนาดใหญ่/ไม่มีเครื่องหมาย)
   6.1 บน ESP32 long และ int มี ขนาดเท่ากัน คือ 4 ไบต์ (32-bit) → ขอบเขตเท่ากัน
   
   6.2 ถ้าเก็บ ค่าบวกขนาดใหญ่มาก → ใช้ unsigned long long ซึ่งรองรับถึง ~18.4 quintillion (2^64 - 1)

### 7. ทดลองกับ byte (ข้อมูล 8 บิต)
   เมื่อกำหนด myByte = 256; ผลลัพธ์คือ 0
   เพราะ byte มีค่าตั้งแต่ 0–255 (8 บิต) → 256 จะ ล้น (overflow) → กลับไปที่ 0
