###  1. ทดลองกับ `int` (จำนวนเต็ม) และ `sizeof()`

**1.1**
`int` บน ESP32 ใช้ขนาด **4 ไบต์ (32 bits)**

**1.2**
เมื่อค่าของ `int` เกินขอบเขต เช่น `2147483647 + 1` หรือ `-2147483648 - 1`
→ จะเกิด **Overflow** และ **Underflow** ทำให้ค่ากลับไปอีกฝั่งทันที เช่น
`2147483647 + 1` กลายเป็น `-2147483648`
`-2147483648 - 1` กลายเป็น `2147483647`

---

###  2. ทดลองกับ `float` และ `double` และ `sizeof()`

**คำตอบ:**

* `float` ใช้ **4 ไบต์**
* `double` ใช้ **8 ไบต์**

**สังเกตความแม่นยำ:**

* `float` แสดงทศนิยมได้ \~6–7 ตำแหน่ง
* `double` แสดงทศนิยมได้ \~15 ตำแหน่ง

**ควรใช้ `double` เมื่อ:**

* ต้องการความแม่นยำสูง เช่น
  – คำนวณเชิงฟิสิกส์
  – พิกัด GPS
  – ค่าทางคณิตศาสตร์ที่ต้องละเอียด

---

###  3. ทดลองกับ `char` และ `sizeof()`

**คำตอบ:**

* `char` ใช้ขนาด **1 ไบต์**

**ASCII คืออะไร:**

* `char` เป็นข้อมูลแบบอักขระ
* อักขระแต่ละตัวมีรหัสตัวเลขที่เรียกว่า **ASCII** เช่น
  – `'Z'` = 90
  – `'z'` = 122
* สามารถแปลง `char` เป็น `int` เพื่อดูรหัส ASCII ได้

---

###  4. ทดลองกับ `bool` และ `sizeof()`

**คำตอบ:**

* `bool` ใช้ขนาด **1 ไบต์** (แม้มีแค่ true/false)
* ค่าที่แสดง:
  – `true` = `1`
  – `false` = `0`

---

###  5. ทดลองกับ `long`, `long long`, `unsigned` และ `sizeof()`

**คำตอบ:**

* `long` → 4 ไบต์ (32-bit)
* `long long` → 8 ไบต์ (64-bit)
* `unsigned int` → 4 ไบต์
* `unsigned long` → 4 ไบต์
* `unsigned long long` → 8 ไบต์

**เพิ่มเติม:**

* `long` และ `int` บน ESP32 มีขนาดเท่ากัน = 4 ไบต์
* หากต้องการเก็บค่าบวกขนาดใหญ่มาก → ควรใช้ `unsigned long long`
  – รองรับค่าบวกได้ถึง `18,446,744,073,709,551,615` (`2^64 - 1`)

---

### 6. ทดลองกับ `byte` และ `sizeof()`

**คำตอบ:**

* `byte` ใช้ขนาด **1 ไบต์**
* มีช่วงค่า `0–255`

**เมื่อกำหนด `myByte = 256;` จะได้ผลลัพธ์ = `0`**

* เพราะ **256 เกินขอบเขต** ของ byte (8 บิต)
  → เกิด **overflow** ค่าจะวนกลับจาก `0`

---

##  ส่วนที่ 2: การคำนวณและแปลงชนิดข้อมูลเบื้องต้น

---

###  7. การคำนวณด้วยชนิดข้อมูลต่างกัน (Type Promotion)

**คำตอบ:**

* เมื่อ `int` หาร `float` หรือ `double` → ตัวแปร `int` จะถูก **แปลงโดยอัตโนมัติ** (Implicit Promotion)
  → ผลลัพธ์จะเป็นค่าทศนิยม

* แต่ถ้าแปลง float เป็น int เช่น `(int)3.0`
  → กลายเป็น `int / int` → ผลลัพธ์จะ **ตัดทศนิยมทิ้ง**

**สรุป:**
ชนิดข้อมูลมีผลโดยตรงต่อชนิดของผลลัพธ์

---

###  8. การแปลงชนิดข้อมูล (Explicit Type Casting)

**คำตอบ:**
**สถานการณ์ที่ควรใช้ Type Casting (แปลงชนิดข้อมูลแบบเจาะจง):**

1.  ป้องกันการคำนวณผิดพลาด
   เช่น `(float)count / total` แทน `int / int` เพื่อไม่ให้ทศนิยมถูกตัด

2.  ควบคุมชนิดของผลลัพธ์
   เช่น แปลง `float → int` เพื่อให้ไม่สนใจค่าทศนิยม

3.  แปลงเพื่อใช้กับค่ารหัส
   เช่น `char → int` เพื่อดูรหัส ASCII

4.  ทำให้โค้ดชัดเจนและควบคุมได้
   ไม่ต้องพึ่งการแปลงอัตโนมัติที่อาจไม่ตรงตามที่ต้องการ

