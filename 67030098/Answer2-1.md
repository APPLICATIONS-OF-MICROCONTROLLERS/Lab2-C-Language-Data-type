2. ทดลองกับ int (จำนวนเต็ม)
```md
2.1 ตรงตามหลักการทางคณิตศาสตร์ เนื่องจาก int มีค่าตั้งต้นเป็น 100 และแสดงผลออกมาเป็น 100 ตามที่คาดไว้

2.2 ตรงตามหลักการทางคณิตศาสตร์ ค่าที่เก็บได้คือ 2147483647 ซึ่งเป็นค่ามากที่สุดของ int 32-bit แบบ signed

2.3 ไม่ตรงกับหลักคณิตศาสตร์ เพราะเกิด Integer Overflow ทำให้ค่ากลับไปเป็นค่าติดลบ (-2147483648) แทนที่จะมากขึ้น

2.4 ตรงตามหลักการทางคณิตศาสตร์ -2147483648 เป็นค่าต่ำสุดที่ชนิด int 32-bit signed สามารถเก็บได้

2.5 ไม่ตรงกับหลักคณิตศาสตร์ เพราะเกิด Integer Underflow ทำให้ค่ากลับไปยังค่าบวกสูงสุด (2147483647) แทนที่จะลดลง

```

3. ทดลองกับ float และ double (ทศนิยม)
```md
3.1 float แสดงทศนิยมได้แค่ประมาณ 7-8 ตำแหน่งเท่านั้น ส่วน double แสดงทศนิยมได้มากถึง 15 ตำแหน่ง ทำให้ค่าของ double มีความแม่นยำมากกว่า

3.2 ควรใช้ double เมื่อเราต้องการเก็บค่าที่มีความแม่นยำสูง เช่น การคำนวณวิศวกรรม, คณิตศาสตร์ขั้นสูง หรือฟิสิกส์

```

4. ทดลองกับ char (อักขระ)
```md
4.1 ค่าตัวเลข ASCII มีความสัมพันธ์โดยตรงกับอักขระ เช่น 'Z' = 90 และ 122 = 'z' เพราะในระบบคอมพิวเตอร์ ตัวอักษรถูกเก็บเป็นเลข ASCII

4.2 สามารถค้นหาความสัมพันธ์ระหว่างตัวเลขและอักขระทั้งหมดได้จาก ตาราง ASCII (ASCII Table)

4.3 นักเขียนโปรแกรม ไม่สามารถกำหนดค่า ASCII เองได้ เพราะมันเป็นมาตรฐานที่กำหนดไว้แล้วโดย ANSI และ Unicode

```

5. ทดลองกับ bool (ตรรกะ)
```md
true แสดงผลเป็น 1, false แสดงผลเป็น 0

```

6. ทดลองกับ long, long long, unsigned int, unsigned long, unsigned long long (จำนวนเต็มขนาดใหญ่/ไม่มีเครื่องหมาย)
```md
6.1 ใช่, บน ESP32 ชนิด long มีขนาดเท่ากับ int คือ 32-bit

6.2 ถ้าต้องการเก็บค่าจำนวนเต็มบวกที่ใหญ่ที่สุด ควรใช้ชนิด unsigned long long ซึ่งเก็บได้สูงถึงประมาณ 18,446,744,073,709,551,615 (2⁶⁴ - 1)

```

7. ทดลองกับ byte (ข้อมูล 8 บิต)
```md
เมื่อ myByte ถูกกำหนดให้เป็น 256 ผลลัพธ์ที่ได้คือ 0 เนื่องจาก byte มีขอบเขตระหว่าง 0–255 (8 บิต) ดังนั้นค่าที่เกินจะวนกลับไปเริ่มใหม่

```
