คำถาม

2.1 สังเกตผลจากการรันโคิดในส่วน 2.1 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
ตอบ ตรงตามหลักการทางคณิตศาสตร์
การกำหนดค่า int myInteger = 100; และแสดงค่าด้วย Serial.println() ให้ผลลัพธ์ที่ถูกต้อง เพราะ 100 อยู่ในช่วงค่าที่ int รองรับได้

2.2 สังเกตผลจากการรันโคิดในส่วน 2.2 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
ตอบ ตรงตามหลักคณิตศาสตร์
2147483647 คือค่าสูงสุดของ int แบบ 32-bit (2^31 - 1)

2.3 สังเกตผลจากการรันโคิดในส่วน 2.3 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
ตอบ ไม่ตรงตามหลักคณิตศาสตร์ เพราะการบวกเกินค่ามากที่สุดของ int จะเกิด Overflow ทำให้ค่าไม่เป็นไปตามที่ควร

2.4 สังเกตผลจากการรันโคิดในส่วน 2.4 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
ตอบ ตรงตามหลักคณิตศาสตร์ เพราะ -2147483648 เป็นค่าต่ำสุดของ int 32-bit ที่ยังอยู่ในขอบเขตพอดี

2.5 สังเกตผลจากการรันโคิดในส่วน 2.5 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
ตอบ ไม่ตรงตามหลักคณิตศาสตร์ เพราะค่าที่น้อยกว่าขอบเขตต่ำสุดจะเกิด Underflow และให้ผลลัพธ์ที่ไม่ถูกต้อง


คำตอบ
3.1 คุณสังเกตเห็นความแตกต่างของความแม่นยำระหว่าง float และ double อย่างไร?
ตอบ จากการทดลองและสังเกตผลลัพธ์ที่ได้จากการแสดงค่าตัวแปรชนิด float และ double พบว่า float สามารถเก็บค่าทศนิยมได้ประมาณ 6-7 ตำแหน่งหลังจุดทศนิยม ในขณะที่ double สามารถเก็บค่าทศนิยมได้มากกว่าคือประมาณ 15-16 ตำแหน่ง ดังนั้นค่าที่เก็บใน double จึงมีความแม่นยำมากกว่า float อย่างชัดเจน โดยเฉพาะเมื่อต้องเก็บค่าทศนิยมที่มีความยาวมากหรือเมื่อต้องทำการคำนวณหลายครั้งต่อเนื่อง ซึ่งค่าของ float จะเริ่มคลาดเคลื่อนเร็วกว่ามาก

3.2 สถานการณ์ใดที่คุณควรเลือกใช้ double แทน float?
ตอบ การเลือกใช้ double แทน float ควรทำในกรณีที่โปรแกรมต้องการความแม่นยำในการคำนวณสูง เช่น การคำนวณเชิงวิทยาศาสตร์ วิศวกรรม การเงิน หรือการทำงานกับข้อมูลที่มีขนาดใหญ่และมีความละเอียดสูง เช่น การวิเคราะห์ข้อมูล หรือการประมวลผลข้อมูลเชิงสถิติที่มีค่าทศนิยมจำนวนมาก นอกจากนี้ double ยังเหมาะสำหรับการคำนวณที่ต้องสะสมค่าทศนิยมในระยะยาวเพื่อป้องกันการสูญเสียความแม่นยำ ในขณะที่ float อาจเหมาะสมกว่าในกรณีที่ต้องการประหยัดหน่วยความจำหรือเพิ่มความเร็วในการประมวลผล เช่น ในระบบฝังตัว (Embedded System) หรือการพัฒนาเกมบางประเภท

คำถาม

4.1 ค่าตัวเลข (ASCII value) มีความสัมพันธ์กับอักขระอย่างไร?
ตอบ จากการทดลองโดยกำหนดตัวแปร char myChar = 'Z'; แล้วแปลงค่า char เป็น int พบว่าได้ค่า 90 ซึ่งตรงกับรหัส ASCII ของตัวอักษร Z นอกจากนี้ เมื่อกำหนด myChar = 122; ซึ่งเป็นค่าจำนวนเต็ม แล้วพิมพ์ค่า myChar ออกมาจะได้ผลลัพธ์เป็นอักขระ 'z'
สรุป: ค่าตัวเลขในระบบ ASCII มีความสัมพันธ์โดยตรงกับตัวอักขระ คือ ตัวอักษรแต่ละตัวจะถูกแทนด้วยเลขเฉพาะในระบบ ASCII และสามารถแปลงไปมาได้ระหว่างตัวเลขกับตัวอักษร


4.2 ถ้าอยากทราบความสัมพันธ์ระหว่างตัวเลขกับอักขระทั้งหมด สามารถหาได้จากเอกสารใด หรือแหล่งอ้างอิงใด
ตอบ สามารถดูได้จากเอกสารหรือเว็บไซต์ที่แสดง ตาราง ASCII (ASCII Table) เช่น:
- เว็บไซต์: www.asciitable.com
- หนังสือเรียนเกี่ยวกับภาษา C หรือระบบคอมพิวเตอร์พื้นฐาน
- คู่มืออ้างอิงที่เกี่ยวกับมาตรฐาน ANSI

4.3 จากข้อ 4.2 นักเขียนโปรแกรมสามารถกำหนดขึ้นเองได้ หรือมีเอกสารใดกำกับอยู่
ตอบ รหัส ASCII เป็นมาตรฐานที่ถูกกำหนดโดย ANSI และได้รับการยอมรับในระดับสากล ซึ่งหมายความว่า นักเขียนโปรแกรมไม่สามารถกำหนดค่าเหล่านี้เองได้ หากต้องการสร้างระบบรหัสใหม่ ต้องสร้างให้ทั้งระบบเข้าใจร่วมกัน และมักใช้ในกรณีเฉพาะ เช่น การเข้ารหัสข้อมูล
โดยทั่วไปในการเขียนโปรแกรมควรยึดตามรหัส ASCII หรือ Unicode ที่มีเอกสารกำกับและมาตรฐานรองรับ

คำถาม
5.1 true และ false ถูกแสดงผลเป็นค่าใดบน Serial Monitor?
ตอบ จากการทดลองพบว่า เมื่อกำหนด myBool = true; แล้วพิมพ์ออกทาง Serial.println(myBool); ได้ผลลัพธ์เป็น 1
เมื่อกำหนด myBool = false; ได้ผลลัพธ์เป็น 0
สรุป: ค่าความจริง true จะถูกแสดงเป็นเลข 1 และ false แสดงเป็นเลข 0 เนื่องจากในระบบดิจิทัลและภาษาคอมพิวเตอร์ เช่น C/C++ ค่าความจริงถูกแทนด้วยตัวเลข 1 และค่าความเท็จเป็น 0

คำถาม

6.1 บน ESP32, long มีขอบเขตเท่ากับ int หรือไม่?
ตอบ จากการทดลองเมื่อกำหนดค่า long myLong = 4000000000L; บน ESP32 พบว่าเกิด overflow และพิมพ์ค่าผิดพลาด
สรุป: long บน ESP32 มีขนาด 32 บิต เท่ากับ int
ดังนั้น ขอบเขตของ long และ int จึงเท่ากัน คือเก็บได้ในช่วงประมาณ −2,147,483,648 ถึง 2,147,483,647

6.2 ชนิดข้อมูลใดที่ต้องใช้หากต้องการเก็บค่าจำนวนเต็มบวกที่ใหญ่ที่สุด?
ตอบ จากการทดลอง unsigned int และ unsigned long สามารถเก็บได้ถึง 4,294,967,295 (32-bit)
unsigned long long สามารถเก็บได้ถึงประมาณ 18,446,744,073,709,551,615 (64-bit)
สรุป: ถ้าต้องการเก็บค่าจำนวนเต็มบวกที่ใหญ่ที่สุดบน ESP32 ควรใช้ชนิดข้อมูล
unsigned long long ซึ่งรองรับค่าขนาดใหญ่ที่สุดในกลุ่มนี้

คำถาม

7.1 เมื่อ myByte ถูกกำหนดให้เป็น 256 ผลลัพธ์ที่ได้คืออะไร และเพราะเหตุใด?
ตอบ จากการทดลองเมื่อกำหนด myByte = 256; แล้วพิมพ์ค่าด้วย Serial.println(myByte); ได้ผลลัพธ์เป็น 0
สาเหตุ byte เป็นชนิดข้อมูล 8 บิต ซึ่งเก็บค่าได้ระหว่าง 0 ถึง 255 เท่านั้น
เมื่อใส่ค่า 256 ซึ่งเกินขอบเขต ตัวแปรจะ วนกลับเป็น 0 เนื่องจากล้นค่าที่เก็บได้ (overflow)
โดยระบบจะตัดเลขที่เกิน 8 บิตออก และเก็บเฉพาะบิตล่างสุด ซึ่งกรณีนี้คือ 00000000 (ค่าศูนย์)



