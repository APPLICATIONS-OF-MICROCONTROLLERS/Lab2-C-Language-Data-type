2. ทดลองกับ int (จำนวนเต็ม):
2.1 สังเกตผลจากการรันโคิดในส่วน 2.1 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
ตรงตามหลักการทางคณิตศาสตร์
เหตุผล: ค่า 100 อยู่ในช่วงที่ int สามารถเก็บได้ จึงแสดงผลถูกต้อง

2.2 สังเกตผลจากการรันโคิดในส่วน 2.2 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
ตรงตามหลักการทางคณิตศาสตร์
เหตุผล: ค่า 2,147,483,647 เป็นค่าสูงสุดของ int (32-bit signed) ซึ่งยังอยู่ในขอบเขต จึงแสดงผลถูกต้อง

2.3 สังเกตผลจากการรันโคิดในส่วน 2.3 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
ไม่ตรงตามหลักการทางคณิตศาสตร์ปกติ
เหตุผล: เกิด Integer Overflow เมื่อค่าเกินขีดจำกัดสูงสุดของ int ทำให้ค่าวนกลับไปเป็นค่าต่ำสุด

2.4 สังเกตผลจากการรันโคิดในส่วน 2.4 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
ตรงตามหลักการทางคณิตศาสตร์
เหตุผล: ค่า -2,147,483,648 เป็นค่าต่ำสุดของ int (32-bit signed) ซึ่งยังอยู่ในขอบเขต จึงแสดงผลถูกต้อง

2.5 สังเกตผลจากการรันโคิดในส่วน 2.5 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
ไม่ตรงตามหลักการทางคณิตศาสตร์ปกติ
เหตุผล: เกิด Integer Underflow เมื่อค่าต่ำกว่าขีดจำกัดต่ำสุดของ int ทำให้ค่าวนกลับไปเป็นค่าสูงสุด

3. ทดลองกับ float และ double (ทศนิยม)
3.1 คุณสังเกตเห็นความแตกต่างของความแม่นยำระหว่าง float และ double อย่างไร?
Float: ให้ความแม่นยำประมาณ 6-7 ตำแหน่งทศนิยม (ในตัวอย่างคือ 3.14159265 กลายเป็น 3.1415927 แสดงการปัดเศษ)
Double: ให้ความแม่นยำสูงกว่ามาก ประมาณ 15-17 ตำแหน่งทศนิยม (ในตัวอย่างคือ 3.141592653589793 แสดงผลได้ครบถ้วน)

3.2 สถานการณ์ใดที่คุณควรเลือกใช้ double แทน float?
ต้องการความแม่นยำสูงมาก: เช่น การคำนวณทางวิทยาศาสตร์, การเงิน หรือวิศวกรรมที่ต้องการความละเอียดสูง.
ลดข้อผิดพลาดสะสมจากการปัดเศษ: ในการคำนวณซับซ้อนหลายขั้นตอน.
ช่วงของตัวเลขที่กว้างกว่า: สำหรับบางการคำนวณที่ต้องการค่าขนาดใหญ่หรือเล็กมากๆ.
API/ไลบรารีที่กำหนด: เมื่อไลบรารีที่ใช้ต้องการ double.
ข้อจำกัดด้านหน่วยความจำ/ประสิทธิภาพไม่เป็นปัญหาหลัก: เพราะ double ใช้ทรัพยากรมากกว่า float เล็กน้อยแต่ให้ความแม่นยำที่เหนือกว่า.

4. ทดลองกับ char (อักขระ)
4.1 ค่าตัวเลข (ASCII value) มีความสัมพันธ์กับอักขระอย่างไร?
อักขระทุกตัว (เช่น 'Z', 'a', '1', '!') จะมี ค่าตัวเลขเฉพาะตัว กำหนดไว้ ซึ่งเรียกว่า รหัส ASCII (หรือ Unicode) คอมพิวเตอร์จะเก็บและประมวลผลอักขระในรูปของตัวเลขนี้

4.2 ถ้าอยากทราบความสัมพันธ์ระหว่างตัวเลขกับอักขระทั้งหมด สามารถหาได้จากเอกสารใด หรือแหล่งอ้างอิงใด
หาได้จาก ตาราง ASCII (ASCII Table) หรือ ตาราง Unicode บนอินเทอร์เน็ต (เช่น Wikipedia, เว็บไซต์สอนเขียนโปรแกรม)

4.3 จากข้อ 4.2 นักเขียนโปรแกรมสามารถกำหนดขึ้นเองได้ หรือมีเอกสารใดกำกับอยู่
ไม่สามารถกำหนดขึ้นเองได้ ความสัมพันธ์นี้ถูกกำหนดโดย มาตรฐานสากล (เช่น ASCII และ Unicode) เพื่อให้ระบบคอมพิวเตอร์ทั่วโลกสื่อสารและแสดงผลอักขระได้อย่างถูกต้องตรงกัน

5. ทดลองกับ bool (ตรรกะ)
5.1 true และ false ถูกแสดงผลเป็นค่าใดบน Serial Monitor?
true ถูกแสดงผลเป็น 1
false ถูกแสดงผลเป็น 0

6. ทดลองกับ long, long long, unsigned int, unsigned long, unsigned long long (จำนวนเต็มขนาดใหญ่/ไม่มีเครื่องหมาย)
6.1 บน ESP32, long มีขอบเขตเท่ากับ int หรือไม่?
ใช่ บน ESP32, long มีขอบเขตเท่ากับ int คือเป็น 32-bit signed integer (ประมาณ −2 พันล้านถึง 2 พันล้าน) หากใส่ค่าเกินจะเกิด Overflow (เช่น 4,000,000,000 ใน long กลายเป็นค่าติดลบ).

6.2 ชนิดข้อมูลใดที่ต้องใช้หากต้องการเก็บค่าจำนวนเต็มบวกที่ใหญ่ที่สุด?
ต้องใช้ชนิดข้อมูล unsigned long long ซึ่งเป็น 64-bit unsigned integer และสามารถเก็บค่าจำนวนเต็มบวกได้ใหญ่ที่สุด 

8. ทดลองกับ byte (ข้อมูล 8 บิต)
เมื่อ myByte ถูกกำหนดให้เป็น 256 ผลลัพธ์ที่ได้คืออะไร และเพราะเหตุใด?
ผลลัพธ์ที่ได้: เมื่อ myByte ถูกกำหนดให้เป็น 256 ผลลัพธ์ที่แสดงบน Serial Monitor คือ 0
เพราะเหตุใด:
ชนิดข้อมูล byte เป็นชนิดข้อมูลจำนวนเต็มที่ ไม่มีเครื่องหมาย (unsigned) และมีขนาด 8 บิต (8-bit) ซึ่งหมายความว่าสามารถเก็บค่าได้ตั้งแต่ 0 ถึง 255 เท่านั้น
เมื่อคุณพยายามกำหนดค่า 256 ให้กับ myByte ซึ่งเกินขอบเขตสูงสุดที่ 255 จะเกิดเหตุการณ์ที่เรียกว่า "Integer Overflow"
ในกรณีของ unsigned integer เมื่อเกิด Overflow ค่าจะวนกลับมาเริ่มต้นที่ 0 เหมือนกับการนับวงกลม:
0, 1, ..., 254, 255
พอถึง 256 จะวนกลับไปที่ 0
257 จะวนกลับไปที่ 1
และวนไปเรื่อยๆ
ดังนั้น 256 คือ 255 + 1 ซึ่งเมื่อเกิน 255 ก็จะวนกลับไปที่ 0 นั่นเอง
