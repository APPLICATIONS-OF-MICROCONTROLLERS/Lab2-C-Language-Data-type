__คำถาม__

2.1  สังเกตผลจากการรันโคิดในส่วน 2.1 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
ิ     ตอบ ตรง เพราะค่า 100 อยู่ในช่วงที่ int รองรับ จึงแสดงผลถูกต้อง

2.2  สังเกตผลจากการรันโคิดในส่วน 2.2 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
     ตอบ ตรง เพราะค่า 2147483647 คือค่าสูงสุดของ int 32-bit แสดงผลได้ถูกต้อง

2.3  สังเกตผลจากการรันโคิดในส่วน 2.3 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
     ตอบ ไม่ตรง เพราะเกิด overflow ค่าที่ได้เกินขอบเขตของ int จึงวนกลับเป็นค่าติดลบ

2.4  สังเกตผลจากการรันโคิดในส่วน 2.4 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
     ตอบ ตรง เพราะ-2147483648 คือค่าต่ำสุดของ int 32-bit แสดงผลได้ถูกต้อง

2.5  สังเกตผลจากการรันโคิดในส่วน 2.5 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
     ตอบ ไม่ตรง เพราะเกิด underflow ค่าที่ได้ต่ำกว่าขอบเขตของ int ทำให้วนกลับเป็นค่าบวกสูงสุด


__คำถาม__ 

3.1 คุณสังเกตเห็นความแตกต่างของความแม่นยำระหว่าง float และ double อย่างไร? 
    ตอบ double แม่นยำกว่า float เพราะเก็บทศนิยมได้มากกว่า

3.2 สถานการณ์ใดที่คุณควรเลือกใช้ double แทน float?
    ตอบ ใช้ double เมื่อคำนวณต้องการความแม่นยำสูง เช่น วิศวกรรมหรือการเงิน


__คำถาม__ 

4.1 ค่าตัวเลข (ASCII value) มีความสัมพันธ์กับอักขระอย่างไร?
    ตอบ เลข ASCII แทนอักขระแต่ละตัว เช่น 'v' = 65

4.2 ถ้าอยากทราบความสัมพันธ์ระหว่างตัวเลขกับอักขระทั้งหมด สามารถหาได้จากเอกสารใด หรือแหล่งอ้างอิงใด
    ตอบ ดูได้จาก ASCII Table บนเว็บไซต์หรือเอกสารมาตรฐาน

4.3 จากข้อ 4.2 นักเขียนโปรแกรมสามารถกำหนดขึ้นเองได้ หรือมีเอกสารใดกำกับอยู่
    ตอบ นักเขียนโปรแกรม ไม่สามารถกำหนดเองได้ ต้องตามมาตรฐาน ASCII


__คำถาม__ 

5.1 true และ false ถูกแสดงผลเป็นค่าใดบน Serial Monitor?
ตอบ true = 1, false = 0 บน Serial Monitor


__คำถาม__ 

6.1 บน ESP32, long มีขอบเขตเท่ากับ int หรือไม่?
    ตอบ long เท่ากับ int (ทั้งคู่ 32-bit บน ESP32)

6.2 ชนิดข้อมูลใดที่ต้องใช้หากต้องการเก็บค่าจำนวนเต็มบวกที่ใหญ่ที่สุด?
    ตอบ ใช้ unsigned long long สำหรับค่าบวกที่ใหญ่ที่สุด


__คำถาม__ 

7.1 เมื่อ myByte ถูกกำหนดให้เป็น 256 ผลลัพธ์ที่ได้คืออะไร และเพราะเหตุใด?
    ตอบ ได้ 0 เพราะ byte เก็บได้แค่ 0–255 → 256 ทำให้ overflow