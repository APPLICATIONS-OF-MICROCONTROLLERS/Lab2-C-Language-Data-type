# สรุปผลและคำถามท้ายการทดลอง

## สรุปผลการทดลอง



## คำถามท้ายการทดลอง

1. นักศึกษาได้เรียนรู้อะไรบ้างเกี่ยวกับความแตกต่างและคุณสมบัติของชนิดข้อมูลแต่ละประเภทบน ESP32 (เช่น int, float, char, bool, long, long long, unsigned int, byte, double)
    ตอบ  ชนิดข้อมูลจำนวนเต็ม:

int: 4 bytes, -2,147,483,648 ถึง 2,147,483,647
long: 4 bytes, เท่ากับ int บน ESP32
long long: 8 bytes, -9,223,372,036,854,775,808 ถึง 9,223,372,036,854,775,807
unsigned int: 4 bytes, 0 ถึง 4,294,967,295
byte: 1 byte, 0 ถึง 255
bool: 1 byte, true/false (แสดงเป็น 1/0)

ชนิดข้อมูลจำนวนจริง:

float: 4 bytes, ความแม่นยำ ~7 หลัก
double: 8 bytes, ความแม่นยำ ~15 หลัก

ชนิดข้อมูลตัวอักษร:

char: 1 byte, เก็บอักขระหรือค่า ASCII

2. ความสำคัญของการเลือกใช้ชนิดข้อมูลที่เหมาะสมในการเขียนโปรแกรมคืออะไร?

   ตอบ ประหยัดหน่วยความจำ (RAM/Flash)
เพิ่มความเร็วในการประมวลผล
หลีกเลี่ยง overflow/underflow

ด้านความแม่นยำ:

เลือกความแม่นยำที่เหมาะสมกับงาน
หลีกเลี่ยงการสูญเสียข้อมูล

3. ถ้านักศึกษาต้องการเก็บค่าเวลา (เป็นมิลลิวินาที) ซึ่งอาจมีค่าสูงถึงหลายพันล้านมิลลิวินาที นักศึกษาควรใช้ชนิดข้อมูลใดบน ESP32

   ตอบ unsigned long long (8 bytes)

5. อธิบายความแตกต่างระหว่าง float และ double ในแง่ของขนาดหน่วยความจำและความแม่นยำ
   ตอบ float ขนาด 4 bytes ความแม่นยำ ประมามณ 7 หลักสำคัญ และ  double ขนาด 8 bytes ความแม่นยำประมาณ 15 หลักสำคัญ

7. อธิบายแนวคิดเรื่อง "Overflow" และ "Underflow" ที่เกิดขึ้นกับชนิดข้อมูลจำนวนเต็ม (เช่น int, byte) พร้อมยกตัวอย่างจากใบงานนี้

   ตอบ Overflow: เกิดเมื่อค่าเกินขอบเขตสูงสุด
   myInteger = 2147483647 + 10; 
Serial.print("myInteger = 2147483647 + 1 ผลลัพธ์: ");
Serial.println(myInteger);
Underflow: เกิดเมื่อค่าต่ำกว่าขอบเขตต่ำสุด
myInteger = -2147483648 - 1; 
Serial.print("myInteger = -2147483648 - 1 ผลลัพธ์: ");
Serial.println(myInteger);
 

9. การทราบขนาดของชนิดข้อมูลด้วย sizeof() มีประโยชน์อย่างไรในการเขียนโปรแกรมสำหรับไมโครคอนโทรลเลอร์ที่มีหน่วยความจำจำกัด?
    ตอบ การประหยัดหน่วยความจำ ,การจัดการหน่วยความจำ เป็นต้น 
