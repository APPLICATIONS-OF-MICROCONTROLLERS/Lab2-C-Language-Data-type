คำถาม

2.1 สังเกตผลจากการรันโคิดในส่วน 2.1 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
- ตรงตามหลักการทางคณิตศาสตร์ 
เพราะ: int ถูกกำหนดค่าเป็น 100 ซึ่งอยู่ในช่วงค่าปกติของ int และสามารถแสดงผลได้ถูกต้องโดยไม่มีปัญหา

2.2 สังเกตผลจากการรันโคิดในส่วน 2.2 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
- ตรงตามหลักการทางคณิตศาสตร์
เพราะ: ค่านี้คือค่าสูงสุดที่ int แบบ signed 32-bit รองรับได้

2.3 สังเกตผลจากการรันโคิดในส่วน 2.3 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
- ไม่ตรงตามหลักการทางคณิตศาสตร์
เพราะ: การบวก 1 กับค่าสูงสุดของ int ทำให้เกิด Overflow (ล้นบวก) ซึ่งทำให้ค่ากลับไปเริ่มต้นที่ค่าต่ำสุดของ int (-2,147,483,648)

2.4 สังเกตผลจากการรันโคิดในส่วน 2.4 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
- ตรงตามหลักการทางคณิตศาสตร์
เพราะ: ค่านี้คือค่าต่ำสุดของ int แบบ signed 32-bit ซึ่งสามารถเก็บได้พอดีโดยไม่มีปัญหา

2.5 สังเกตผลจากการรันโคิดในส่วน 2.5 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
- ไม่ตรงตามหลักการทางคณิตศาสตร์
เพราะ: การลบ 1 จากค่าต่ำสุดของ int จะเกิด Underflow (ล้นลบ) ทำให้ค่ากลับไปที่ค่าสูงสุดของ int (2,147,483,647)

คำถาม

3.1 คุณสังเกตเห็นความแตกต่างของความแม่นยำระหว่าง float และ double อย่างไร?
- double สามารถเก็บค่าทศนิยมได้แม่นยำกว่า float

3.2 สถานการณ์ใดที่คุณควรเลือกใช้ double แทน float?
- คำนวณที่ต้องการความแม่นยำสูง และการจัดการค่าทศนิยมที่ยาวมาก

คำถาม

4.1 ค่าตัวเลข (ASCII value) มีความสัมพันธ์กับอักขระอย่างไร?
- ASCII คือค่าตัวเลขที่แทนอักขระ char

4.2 ถ้าอยากทราบความสัมพันธ์ระหว่างตัวเลขกับอักขระทั้งหมด สามารถหาได้จากเอกสารใด หรือแหล่งอ้างอิงใด
- หาจาก ASCII Table เช่น asciitable.com

4.3 จากข้อ 4.2 นักเขียนโปรแกรมสามารถกำหนดขึ้นเองได้ หรือมีเอกสารใดกำกับอยู่
- ไม่สามารถกำหนดเองได้ เพราะเป็นมาตรฐาน ANSI/ASCII

คำถาม

5.1 true และ false ถูกแสดงผลเป็นค่าใดบน Serial Monitor?
- true จะแสดงผลเป็น 1 false จะแสดงผลเป็น 0

คำถาม

6.1 บน ESP32, long มีขอบเขตเท่ากับ int หรือไม่?
- int และ long มีขอบเขตเท่ากัน

6.2 ชนิดข้อมูลใดที่ต้องใช้หากต้องการเก็บค่าจำนวนเต็มบวกที่ใหญ่ที่สุด?
- unsigned long long เพราะมีขนาด 64-bit และไม่มีเครื่องหมาย จึงสามารถเก็บค่าบวกได้สูง

คำถาม

7.1 เมื่อ myByte ถูกกำหนดให้เป็น 256 ผลลัพธ์ที่ได้คืออะไร และเพราะเหตุใด?
- ผลลัพธ์คือ 0 เพราะ: byte เก็บได้แค่ 8 บิต (0–255) ค่า 256 เกินขอบเขต → เกิด Overflow → เหลือค่า 0
