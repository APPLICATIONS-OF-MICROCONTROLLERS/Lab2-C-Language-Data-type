# สรุปผลและคำถามท้ายการทดลอง

## สรุปผลการทดลอง



## คำถามท้ายการทดลอง

1. นักศึกษาได้เรียนรู้อะไรบ้างเกี่ยวกับความแตกต่างและคุณสมบัติของชนิดข้อมูลแต่ละประเภทบน ESP32 (เช่น int, float, char, bool, long, long long, unsigned int, byte, double)

        int: ใช้เก็บจำนวนเต็ม มีขนาด 4 ไบต์ (-2,147,483,648 ถึง 2,147,483,647) 
        float: ใช้เก็บทศนิยม (ค่าลอยตัว) ขนาด 4 ไบต์ ความแม่นยำ 6-7 หลัก
        double: บน ESP32 ขนาด 8 ไบต์ แต่ความแม่นยำอาจไม่ต่างจาก float มากนัก (ตามแพลตฟอร์ม)
        char: ใช้เก็บอักขระ 1 ตัว หรือเก็บเลขจำนวนเต็มขนาดเล็ก (-128 ถึง 127)
        bool: ใช้เก็บค่า true/false (1 หรือ 0)
        long: จำนวนเต็มขนาด 4 ไบต์ เช่นเดียวกับ int บน ESP32
        long long: จำนวนเต็มขนาด 8 ไบต์ เหมาะกับค่าตัวเลขขนาดใหญ่มาก
        unsigned int: จำนวนเต็มบวก (ไม่มีค่าลบ) ขนาด 4 ไบต์ (0 ถึง 4,294,967,295)
        byte: จำนวนเต็มบวกขนาด 1 ไบต์ (0 ถึง 255)

2. ความสำคัญของการเลือกใช้ชนิดข้อมูลที่เหมาะสมในการเขียนโปรแกรมคืออะไร?

       ประหยัดหน่วยความจำ: เลือกชนิดข้อมูลให้เหมาะกับค่าที่ต้องใช้จริง จะช่วยประหยัด RAM ของไมโครคอนโทรลเลอร์ ซึ่งมีจำกัด
        ประสิทธิภาพ: ใช้ชนิดข้อมูลที่เล็กลงช่วยให้ประมวลผลเร็วขึ้น
        ป้องกันข้อผิดพลาด: ลดปัญหา overflow, underflow หรือการเก็บค่าผิดประเภท
        ความแม่นยำ: ชนิดข้อมูลที่เหมาะสมทำให้ได้ค่าที่ถูกต้อง ไม่ผิดเพี้ยน

   
3. ถ้านักศึกษาต้องการเก็บค่าเวลา (เป็นมิลลิวินาที) ซึ่งอาจมีค่าสูงถึงหลายพันล้านมิลลิวินาที นักศึกษาควรใช้ชนิดข้อมูลใดบน ESP32

       ควรใช้
        unsigned long (4 ไบต์, 0 ถึง 4,294,967,295)
        หรือ
        unsigned long long (8 ไบต์, 0 ถึง 18,446,744,073,709,551,615)
        ถ้าค่าที่จะเก็บมีโอกาสเกิน 4 พันล้าน

4. อธิบายความแตกต่างระหว่าง float และ double ในแง่ของขนาดหน่วยความจำและความแม่นยำ

        float: ขนาด 4 ไบต์, ความแม่นยำ ~6-7 หลักทศนิยม
        double: ขนาด 8 ไบต์, ความแม่นยำ ~15-16 หลักทศนิยม
        (แต่บน ESP32 บาง compiler อาจ float กับ double มีความแม่นยำเท่ากัน)
        สรุป: double เก็บค่าละเอียดกว่า float แต่กินหน่วยความจำมากกว่า
            

5. อธิบายแนวคิดเรื่อง "Overflow" และ "Underflow" ที่เกิดขึ้นกับชนิดข้อมูลจำนวนเต็ม (เช่น int, byte) พร้อมยกตัวอย่างจากใบงานนี้
        
       Overflow: ค่าที่เพิ่มเกินขอบเขตสูงสุดของชนิดข้อมูล เช่น
        byte x = 255; x = x + 1; // x กลับไปเป็น 0
        Underflow: ค่าที่ลดต่ำกว่าขอบเขตต่ำสุด เช่น
        byte x = 0; x = x - 1; // x กลายเป็น 255
        ตัวอย่างในใบงาน: เมื่อ int เก็บค่าเกิน 2,147,483,647 จะกลายเป็นค่าลบทันที (วนกลับด้าน)


6. การทราบขนาดของชนิดข้อมูลด้วย sizeof() มีประโยชน์อย่างไรในการเขียนโปรแกรมสำหรับไมโครคอนโทรลเลอร์ที่มีหน่วยความจำจำกัด?
   
       ช่วยให้เลือกชนิดข้อมูลได้เหมาะกับปริมาณข้อมูลและข้อจำกัดของอุปกรณ์
        วางแผนการใช้ RAM/ROM ได้แม่นยำ ลดปัญหาหน่วยความจำไม่พอ
        ป้องกันปัญหาโปรแกรมค้างหรือ crash จากการใช้หน่วยความจำเกินจริง
