# สรุปผลและคำถามท้ายการทดลอง

## สรุปผลการทดลอง



## คำถามท้ายการทดลอง

1. นักศึกษาได้เรียนรู้อะไรบ้างเกี่ยวกับความแตกต่างและคุณสมบัติของชนิดข้อมูลแต่ละประเภทบน ESP32 (เช่น int, float, char, bool, long, long long, unsigned int, byte, double)
2. 
int
ขนาด 4 ไบต์ (32-bit)
เก็บค่าจำนวนเต็มทั้งบวกและลบ มีขอบเขตประมาณ -2,147,483,648 ถึง 2,147,483,647
หากเกินขอบเขตจะเกิดการ overflow/underflow

long
บน ESP32 ขนาดเท่ากับ int คือ 4 ไบต์ (32-bit) มีขอบเขตเท่ากับ int จึงไม่เหมาะกับค่าที่เกิน 2 พันล้านขึ้นไป

long long
ขนาด 8 ไบต์ (64-bit)
เก็บจำนวนเต็มขนาดใหญ่ได้มากกว่ามาก เหมาะสำหรับเก็บค่าที่เกินขอบเขตของ long หรือ int

unsigned int, unsigned long
ขนาด 4 ไบต์ (32-bit)
เก็บเฉพาะจำนวนเต็มบวก (0 ถึงประมาณ 4,294,967,295) ไม่มีค่าลบ จึงเพิ่มช่วงค่าบวกได้มากขึ้น

unsigned long long
ขนาด 8 ไบต์ (64-bit)
เก็บจำนวนเต็มบวกขนาดใหญ่มากที่สุดในกลุ่มนี้ (0 ถึงประมาณ 18,446,744,073,709,551,615)

float
ขนาด 4 ไบต์ (32-bit)
เก็บค่าทศนิยมแบบ Single Precision ความแม่นยำประมาณ 6-7 หลักทศนิยม

double
ขนาด 8 ไบต์ (64-bit)
เก็บค่าทศนิยมแบบ Double Precision ความแม่นยำสูงกว่า float (ประมาณ 15 หลักทศนิยม)
เหมาะกับงานที่ต้องการความแม่นยำสูง

char
ขนาด 1 ไบต์ (8-bit)
เก็บอักขระตัวเดียว หรือค่าจำนวนเต็ม 0-255 มีค่าที่สัมพันธ์กับรหัส ASCII

bool
ขนาด 1 ไบต์ เก็บค่าเพียงสองค่า คือ true (1) หรือ false (0)

byte
ขนาด 1 ไบต์
เก็บค่าจำนวนเต็มบวก 0-255 หากเกินขอบเขต เช่น กำหนด 256 จะเกิดการ overflow กลับไปเริ่มนับจาก 0 ใหม่


2. ความสำคัญของการเลือกใช้ชนิดข้อมูลที่เหมาะสมในการเขียนโปรแกรมคืออะไร?

การเลือกชนิดข้อมูล (data type) ที่เหมาะสม มีผลโดยตรงต่อประสิทธิภาพ ความถูกต้อง และความปลอดภัยของโปรแกรม


3. ถ้านักศึกษาต้องการเก็บค่าเวลา (เป็นมิลลิวินาที) ซึ่งอาจมีค่าสูงถึงหลายพันล้านมิลลิวินาที นักศึกษาควรใช้ชนิดข้อมูลใดบน ESP32

unsigned long


4. อธิบายความแตกต่างระหว่าง float และ double ในแง่ของขนาดหน่วยความจำและความแม่นยำ


float เหมาะกับงานทั่วไปที่เน้นความเร็วและใช้หน่วยความจำต่ำ
double เหมาะกับงานที่ต้องการความแม่นยำสูงกว่า แม้จะใช้หน่วยความจำมากขึ้น


5. อธิบายแนวคิดเรื่อง "Overflow" และ "Underflow" ที่เกิดขึ้นกับชนิดข้อมูลจำนวนเต็ม (เช่น int, byte) พร้อมยกตัวอย่างจากใบงานนี้

Overflow เกิดขึ้นเมื่อค่าที่นำไปเก็บ มากเกินกว่าขอบเขตบน ของชนิดข้อมูลนั้น
ระบบจะ วนกลับไปยังค่าต่ำสุด ตามรูปแบบการเข้ารหัสแบบทูส์คอมพลีเมนต์ (Two’s complement)


int myInteger = 2147483647;      // ค่าสูงสุดของ int (32-bit signed)
myInteger = 2147483647 + 1;
Serial.println(myInteger);       // แสดงผล: -2147483648 (เกิด Overflow)


Underflow เกิดขึ้นเมื่อค่าที่นำไปเก็บ น้อยกว่าขอบเขตล่าง ของชนิดข้อมูลนั้น
ระบบจะ วนกลับไปยังค่าสูงสุด


int myInteger = -2147483648;     // ค่าต่ำสุดของ int
myInteger = -2147483648 - 1;
Serial.println(myInteger);       // แสดงผล: 2147483647 (เกิด Underflow)



6. การทราบขนาดของชนิดข้อมูลด้วย sizeof() มีประโยชน์อย่างไรในการเขียนโปรแกรมสำหรับไมโครคอนโทรลเลอร์ที่มีหน่วยความจำจำกัด?

1. รู้ว่าตัวแปรแต่ละตัวใช้หน่วยความจำเท่าไหร่ ทำให้สามารถเลือกชนิดข้อมูลที่เหมาะสมและไม่เปลือง RAM

2. ป้องกันปัญหาโปรแกรมค้างหรือหน่วยความจำล้น โดยเฉพาะเมื่อใช้ตัวแปรหรือ array ขนาดใหญ่

3. ออกแบบการส่งข้อมูลผ่าน Serial หรือ Network ได้แม่นยำ เพราะรู้ว่าต้องส่งข้อมูลกี่ไบต์

4. ช่วยให้โค้ดทำงานเร็วขึ้น และใช้ทรัพยากรคุ้มค่า เลือกชนิดข้อมูลเล็ก ๆ ได้ถ้าไม่ต้องการค่ามาก
