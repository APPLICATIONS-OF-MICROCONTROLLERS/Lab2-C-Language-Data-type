2.1
ผลลัพธ์: myInteger = 100 แสดงเป็น 100

ตรงตามหลักคณิตศาสตร์: ใช่ เพราะ 100 ยังอยู่ในขอบเขตของ int (–2,147,483,648 ถึง 2,147,483,647)

เหตุผล: ค่า 100 เป็นจำนวนเต็มที่สามารถจัดเก็บในตัวแปร int ได้โดยไม่มีปัญหา

2.2
ผลลัพธ์: แสดง 2147483647

ตรงตามหลักคณิตศาสตร์: ใช่

เหตุผล: ค่านี้คือขอบเขตบนสุดของ int (32-bit) ดังนั้นแสดงผลได้ถูกต้อง

2.3
ผลลัพธ์: แสดงเป็น -2147483648

ตรงตามหลักคณิตศาสตร์: ไม่

เหตุผล: เกิด overflow เมื่อค่ามากกว่าขอบเขตของ int มันจะวนกลับไปที่ค่าต่ำสุดของช่วงแทน

2.4
ผลลัพธ์: แสดง -2147483648

ตรงตามหลักคณิตศาสตร์: ใช่

เหตุผล: เป็นค่าต่ำสุดที่ int (32-bit signed) สามารถเก็บได้พอดี

2.5
ผลลัพธ์: แสดงเป็น 2147483647

ตรงตามหลักคณิตศาสตร์: ไม่

เหตุผล: เกิด underflow เมื่อค่าต่ำกว่าขอบเขต มันจะวนกลับไปที่ค่าบนสุดของช่วงแทน

3. ทดลองกับ float และ double
3.1
สังเกต: float แสดงค่าได้ประมาณ 6-7 ตำแหน่งทศนิยมแม้เราจะพิมพ์ 8 ส่วน double แสดงค่าทศนิยมได้มากถึง 15 ตำแหน่ง

สรุป: double มีความแม่นยำสูงกว่า float อย่างชัดเจน

3.2
ควรใช้ double เมื่อ:

ต้องการความแม่นยำสูง เช่น การคำนวณทางวิทยาศาสตร์, คณิตศาสตร์เชิงซ้อน, พิกัด GPS

4. ทดลองกับ char
4.1
ความสัมพันธ์: ตัวอักษรถูกเก็บเป็นค่าตัวเลขในรูปแบบ ASCII เช่น 'Z' = 90, 'z' = 122

4.2
แหล่งอ้างอิง: ตาราง ASCII (ASCII Table) หรือค้นคำว่า “ASCII Table” บน Google

4.3
นักเขียนโปรแกรมไม่สามารถกำหนด ASCII เองได้

เพราะ: ASCII เป็นมาตรฐานที่กำหนดโดย ANSI (American National Standards Institute)

5. ทดลองกับ bool
5.1
ผลลัพธ์ใน Serial Monitor:

true → แสดงเป็น 1

false → แสดงเป็น 0

เหตุผล: ในระบบคอมพิวเตอร์ true ถูกแทนด้วย 1 และ false ด้วย 0

6. ทดลองกับ long, long long, unsigned
6.1
long เท่ากับ int: ใช่ บน ESP32 ทั้ง long และ int เป็น 32-bit

ผลลัพธ์ของ myLong = 4000000000: เกิด overflow เพราะเกิน 2,147,483,647

6.2
ถ้าต้องการเก็บค่าบวกขนาดใหญ่มากที่สุด:

ใช้ unsigned long long (64-bit ไม่มีเครื่องหมาย)

รองรับค่าประมาณ 0 ถึง 18,446,744,073,709,551,615

7. ทดลองกับ byte
ผลลัพธ์ของ myByte = 256:
แสดงเป็น: 0

เหตุผล:

byte เป็นข้อมูลขนาด 8 บิต (0–255)

เมื่อใส่ 256 มันจะวนกลับไปที่ 0 (overflow)

